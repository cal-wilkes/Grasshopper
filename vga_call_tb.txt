library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;

entity vga_call_tb is
end vga_call_tb;

architecture behavior of vga_call_tb is

	component vga_call
		port( clk: in std_logic;
			reset: in std_logic;
			vga_control_10: in std_logic_vector(11 downto 0);
			vga_control_1: in std_logic_vector(11 downto 0);
			vga_control_0: in std_logic_vector(11 downto 0)
			hsync: out STD_LOGIC;
            vsync: out STD_LOGIC;
			);
	end component;
	
	signal clk : std_logic;
	signal reset : std_logic;
	signal vga_control_0 : std_logic_vector(11 downto 0);
	signal vga_control_1 : std_logic_vector(11 downto 0);
	signal vga_control_10 : std_logic_vector(11 downto 0);
	signal hsync : std_logic;
	signal vsync : std_logic;
	
	
	constant clk_period : time := 10 ns;
	
begin
	
	uut: vga_call
		port map(
					clk => clk,
					reset => reset,
					vga_control_0 => vga_control_0,
					vga_control_1 => vga_control_1,
					vga_control_10 => vga_control_10,
					hsync => hsync,
					vsync => vsync
					);
					
	clk_process : process
	begin
		clk <= '0';
		wait for clk_period/2;
		clk <= '1';
		wait for clk_period/2;
	end process;
	
	
	stim_proc : process
	begin
	
		reset <= '0';
		wait for 100 ns;
		reset <= '1';
		wait for 100 ns;
		reset <= '0';
		wait for 100 ns;
		
		vga_control_0 <= "111111111111";
		wait for 100 ns;
		vga_control_0 <= "000000000000";
		wait for 100 ns;
		vga_control_1 <= "111111111111";
		wait for 100 ns;
		vga_control_1 <= "000000000000";
		wait for 100 ns;
		vga_control_10 <= "111111111111";
		wait for 100 ns;
		vga_control_10 <= "000000000000";
		wait for 100 ns;
		wait;
	end process;
	
end;
		